---
title: "Programación Funcional con {purrr}"
author: "Growth Acceleration Partners"
date: "8/12/2021"
output:
  ioslides_presentation:
    widescreen: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(purrr)
```

# purrr: 
"Provee un conjunto de herrramientas para trabajar con funciones y vectores de manera consistente"

# 0. Funciones en R

```{r, eval=FALSE}
nombre_funcion <- function(parametro1, parametro2, ...){
  # [cuerpo de la funcion]
  
  return(valor_a_retornar)
}
```

Tip de vida: dentro del cuerpo de la funcion usar `ctrl` + `alt` + `shift` + `R`

```{r, eval=FALSE}
#' Title
#'
#' @param parametro1 
#' @param parametro2 
#' @param ... 
#'
#' @return
#' @export
#'
#' @examples
nombre_funcion <- function(parametro1, parametro2, ...){
  # [cuerpo de la funcion]
  
  return(valor_a_retornar)
}
```

Este tipo de documentación se llama Roxygen, y esta es la forma de documentar paquetes en R.

## Ambientes en R

Cuando una función se ejecuta, crea su propio ambiente contenido en el ambiente desde donde se llamó la función. La función va a buscar primero los valores dentro de su propio ambiente, y si no existen "saldrá a buscarlos" en los niveles superiores.

```{r}
x <- 1
y <- 2

f <- function(x){
  message('x vale `', x, '`, y vale `', y, '`.')
}

f(x=3)
f(x="AAAAA!!!")
```

Bajo esta perspectiva,la acción de pasarle parámetros a una función lo que hace es declarar esas variables en el nuevo ambiente. Y cuando esta función termina su ejecución, ese ambiente se extingue sin pasarle sus valores a nadie más.

```{r}
cambiar_x <- function(){
  x <- x + 1
  message('Adentro, cambiamos x: ahora vale ', x)
}

cambiar_x()
message('Pero afuera, queda igual: ', x)

```

Por supuesto, para esto es que existe la función `return()`, la cual le "entrega" un objeto del ambiente de la función al siguiente nivel hacia arriba.

```{r}
cambiar_x <- function(x){
  x <- x + 1
  message('Adentro, cambiamos x: ahora vale ', x)
  return(x)
}

x <- cambiar_x(x)
message('Y con una asignación sí cambia: ', x)

```

## Efectos secundarios

Si bien el llamado de `return` es el que le permite a una función enviar valores a otro ambiente, no hay nada que les detenga hacer cambios en memoria de otras maneras, como por ejemplo escribir en el disco (como `write_csv`, `saveRDS`, etc.), o modificar directamente los valores en RAM por referencia (como los mutate de `data.table` `dt[, :=]` o la asignación `<<-`). Estos son llamados efectos secundarios porque si bien no son parte del `return`, generan cambios fuera de su ambiente.



## Funciones puras e impuras

Para que una función se considere pura, debe cumplir:
1. Si la función se llama varias veces con los mismos parámetros, debe siempre retornar el mismo valor (salvo alatoreidad deseada).
2. La función no debe tener efectos secundarios.


```{r}
fpura = function(x,y,z){
  z <- z + mean(c(x,y))
  return(z)
}
```

```{r}
x <- 1
y <- 2
z <- 3

fpura(x,y,z)
fpura(x,y,z)
fpura(x,y,z)

print(c(x,y,z))
```


```{r}
fimpura = function(x,y,z){
  z <<- z + mean(x,y) # modifica valores fuera de su ambiente (mala práctica!)
  print(z)
}
```

```{r}
x <- 1
y <- 2
z <- 3

fimpura(x,y,z)
fimpura(x,y,z)
fimpura(x,y,z)

print(c(x,y,z)) # ambió de valor fuera de la funcion
```

## Listas

Contenedores indexados sin restricciones de clase:

```{r}
lista <- list(sum, c(1,3,5), 'Naranja')
```

Al igual que los vectores atómicos, podemos seleccionar un elemento con `[]`. Con corchetes simples, devuelve una lista de que contiene el (los) elemento(s) indexado(s).

```{r}
# lista[2] == list(c(1,3,5))
lista[2]
```
```{r}
# lista[2:3] == list(c(1,3,5), "Naranja")
lista[2:3]
```


Con corchetes dobles ``[[]]`` retorna el elemento de la lista directaments, sea de la clase que sea

```{r}
# lista[[2]] == c(1,3,5)
lista[[2]]
```

```{r}
# lista[[2]] == c(1,3,5)
class(lista[2])
class(lista[[2]])
```

*Dificultades con las listas:*

1. Pueden (o no) tener nombres
2. Pueden contener otras listas 

```{r}
lista$entrada_con_nombre <- list(mean, vector_con_nombre=letters[1:3], c('a', 'b', 'c'))
```

La función str() es sumamente útil para perderle el miedo a las listas. El parámetro max.level permite especificar hasta qué nivel desgranar

```{r}
str(object = lista)
```

Y el parámetro `max.level` nos ayuda a ver la estructura hasta cierto nivel, lo cual nos sirve para mantener legible la impresión.

```{r}
str(object = lista, max.level = 1)
str(object = lista, max.level = 2)
```

# 1. Programacion funcional

## Minimo Necesario:

"En R, las funciones son ciudadanas de primera clase" -> Existen en el ambiente y se pueden enviar como cualquier otro parámtro a otras funciones

Un *funcional* es una función que recibe otra función entre sus parametros, y devuelve un vector


## Funcionales en R base

La familia de funciones `apply` se llaman así porque *aplican* una función a cada uno de los elementos de un vector (aquí usamos vector de forma muy flexible, refiriéndonos a cualquier objeto indexable). Importante notar que la función se pone sin paréntesis, porque lo que pasamos es el objeto, no la llamada.


```{r}
apply_manual <- function(FUN, X){
  for(Xi in X){
    FXi = FUN(Xi)
    print(FXi)
  }
}

apply_manual(FUN = sqrt, X = 1:10)
```

```{r}
base::apply(X = mtcars, MARGIN = 2, FUN = mean)
base::sapply(X = 1:10, FUN = sqrt) # s viene de 'simplified'
#?lapply; ?vapply; ?tapply
```

Algo importante a notar de esta última llamada es que todas estas funciones conservan los nombres de los elementos por los que iteran. Esto es una excelente práctica para conservar el orden y trazar con mayor facilidad los resultados de estas llamadas, y una acción frecuentemente cómoda es nombrar cada elemento con su mismo valor:

```{r}
aj <- letters[1:10]
names(aj) <- aj
resultado_apply <- lapply(X = aj, FUN = toupper)

names(resultado_apply)
resultado_apply$a
resultado_apply$c
```

Y aunque si bien no es tan inmediatamente legible, la función `set_names` de `purrr` (que llama a la función de `rlang` con el mismo nombre) recibe el vector y un vector de nombres, y devuelve ese mismo vector ya nombrado. Esto permite que no se tenga que romper el camino de llamadas para asignar nombres

```{r}
resultado_apply <- letters[1:10] %>% 
  purrr::set_names(.) %>% # acá recibe el vector, y adicionalmente decimos que el segundo parametro va a ser el mismo vector
  lapply(FUN = toupper)

names(resultado_apply)
resultado_apply$a
resultado_apply$c

```

 
 
 Y para usar funciones con más de un parámetro, estas funciones aprovechan el constructo `...`, que sirve como un "comodín" para pasarle parámetros a una función interna:

```{r}
aplicar_tres_puntos <- function(funcion, ...){
  funcion(...)
}

# con la funcion round
?round
aplicar_tres_puntos(funcion = round, x = 0.5555555, digits = 2)

# con la funcion sort
?sort
aplicar_tres_puntos(funcion = sort, x = c(1,3,2,NA,100))
aplicar_tres_puntos(funcion = sort, x = c(1,3,2,NA,100), decreasing = TRUE)
aplicar_tres_puntos(funcion = sort, x = c(1,3,2,NA,100), decreasing = TRUE, na.last = TRUE)


```


```{r}
raices_cuadradas <- sapply(X = 1:10, FUN = sqrt)
sapply(X = raices_cuadradas, FUN = round, digits = 2)
```

Podemos ver tanto que en la función construida como en las llamadas de sapply, no existe un parámetro `digits`. esta es de la función `round` propiamente, y el constructo `...` permite que se le pase sin requerir que cada parámetro esté declarado explícitamente en la función que la llama. 



# 2. `purrr`

Las funciones `map` del paquete `purrr` vienen a desempeñar el mismo rol iterativo, pero con un conjunto de facilidades que hacen que se acoplen mejor a un esuqema de trabajo moderno en R.

La función básica es `map`, que recibe un vector `.x`, y le aplica la función `.f`. Esta función devuelve una lista donde cada entrada es la evaluación de `.f(.x[i])`

```{r}
purrr::map(.x = 1:10, .f = sqrt)
```


### Notación de fórmula

Si bien las funciones `map` tienen el mismo parámetro `...`, puede resultar más legible y más fácil de escribir las funciones en notación de fórmula. Esto es, se coloca la virgulilla `~` antes de una llamada normal de una función, y se usará la variable `.x` en el parámetro por el que se va a iterar. 

```{r}
## 1. formula notation
purrr::map(.x = 1:10, .f = ~sqrt(.x))
```

La principal ventaja de esta notación es que permite ser más explícito con la intención del código, y admite escencialmente cualquier expresión.

```{r}
purrr::map(.x = 1:10, .f = ~round(sqrt(.x), 2) + 1)
```

Incluso cadenas con el operador pipe `%>%` de magrittr, o el nuevo pipe nativo `|>` de R >=4.1

```{r}
purrr::map(.x = 1:10, 
           .f = ~.x %>% 
             sqrt() %>%
             round(2) 
             + 1)
```

### Modificadores de clase

Si bien las listas son una estructura adecuada para almacenar resultados arbitrarios ya que permiten coleccionar entradas de cualquier clase (e incluso de clases distintas), existen muchos usos donde tener el resultado ennuna lista se vuelve incómodio. Para esto, la familia de funciones incluye `map`s son sufijos que especifican la clase en que se desea recibir el resultado. Por supuesto, las salidas deben ser convertibles a la clase deseada, y es nceesario entender los requisitos de cada una. 

Estas funciones son opinionadas por diseño, ya que desean evitar que una coerción inusual arruine la línea de procesos completa. Esto significa que son más estricas que usar las funciones de coerción `as.integer`, `as.character`, `as.integer`, etc.

```{r}
# doubles
purrr::map_dbl(.x = 1:10, .f = ~round(sqrt(.x), 2) + 1)
```


```{r}
map_int(.x = 1:10, .f = ~round(sqrt(.x), 2) + 1) # frena de doble a enteros
map_int(.x = 1:10, .f = ~as.integer(round(sqrt(.x), 2) + 1)) 
map_lgl(.x = 1:10, .f = ~round(sqrt(.x), 2) + 1) # frena
map_lgl(.x = 1:10, .f = ~as.logical(round(sqrt(.x), 2) + 1)) 
map_chr(.x = 1:10, .f = ~round(sqrt(.x), 2) + 1)
map_df(.x = 1:10, .f = ~round(sqrt(.x), 2) + 1) #data.frame requiere que tengan nombres
```
### Más modificaodres

#### `map2` permite recorrer dos vectores emparejando índices

```{r}
#### 3.1 map2 runs through 2 lists pairwise
purrr::map2(.x = 1:10, .y = 1:10, .f = ~.x + .y)
purrr::map2_int(.x = 1:10, .y = 10:10, .f = ~.x + .y)
```

#### `pmap` generaliza map2 a p vectores

```{r}
list(a = 1:10, b = 1:10, c = 1:10) %>% 
  purrr::pmap(.f = sum)
list(a = 1:10, b = 1:10, c = 1:10) %>% 
  purrr::pmap_int(.f = function(a,b,c) a + b + c)
```

#### `walk` para efectos secundarios

Esta función y sus correspondientes modificaciones `walk2` `pwalk` son idénticas a map excepto que se utilizan solamente para efectos secundarios (escribir en consola, guardar archivos, modificar por referencia, etc), y no deuvuelve ninguna estructua con ningún valor.

```{r}
purrr::walk(.x = 1:10, .f = ~sqrt(.x)) # returns nothing!
```

#### `map_depth` recorre sub elementos de una lista

A veces la estructura de lista funciona muy bien para coleccionar elementos que deben ser tratados igual, pero que queremos iterar sobre cada uno por separado. Para esto, el parámetro `.depth` permite especificar el nivel de la lista por el que se va a iterar.

Por ejemplo, supongamos que tenemos estos tres vectores, y queremos tener un indicador booleano ppara cada número, indicando si es un número par.

```{r}
lista_de_vectores <- list(vector1 = c(1,4,5,6,8,21,22,99),
                                      vector2 = 2^(1:10),
                                      vector3 = seq(21,0,-3))
str(lista_de_vectores)
```

Con `depth = 1`, se comporta igual que una llamada de `map`. Podemos aprovechar y asignarle los nombres de sus valores a cada vector.

```{r}
lista_de_vectores <- map_depth(.x = lista_de_vectores,
                               .depth = 1,
                               .f = ~set_names(.x, .x))
str(lista_de_vectores)
```


```{r}
es_par <- map_depth(.x = lista_de_vectores, 
                    .depth = 2,
                    .f = ~.x %% 2 == 0)
str(es_par)
```


# 3. purrr para análisis de datos 

```{r}
library(palmerpenguins)
penguins
```
## Trucos para trabajar con tablas

- `purrr::keep` y `purrr::discard`nos permiten seleccionar subconjuntos de columnas
- `base::split` nos permite dividir una tabla a una lista de tablas a partir de una lógica

## Demo 1: Gráficos por isla

```{r}

# map: Just do it once! -------------------------------------------------------------

# load some data
pkmn <- fread('pkmn.csv') %>% janitor::clean_names()

# get the mean speed for each type? -> immediate
pkmn[, .(mean_speed = mean(speed)), by = type_1]

# more complex asks: make a plot of hp vs speed for each type separately
pkmn[, .(`???`), by = type]

# long way to facet_wrap()

# Demo 1 -----------------------------------------------------------------------

# tip: split goes from single data.frame to named list of dataframes
type_tables <- pkmn %>% split(., .$type_1)
str(type_tables, 1, give.attr = F)

type_plots <- type_tables %>% 
  map(~ggplot(.x, 
              mapping = aes(x = speed, y = hp)) + 
        geom_point() + 
        theme_minimal())
# call each plot
type_plots$Normal

# slightly better
type_plots <- type_tables %>% 
  map2(.y = names(.),
       ~ggplot(data = .x, 
               mapping = aes(x = speed, y = hp),
               alpha = .85) + 
         geom_smooth(formula = y~x, method = 'lm') + 
         geom_point() + 
         theme_minimal() + 
         ggtitle(.y)) %>% 
  map(.x = ., .f = plotly::ggplotly)

# call each plot
type_plots$Electric
type_plots$Dragon

split_plot <- function(data, split_variable, x_axis, y_axis, static = TRUE){
  split_data <- data %>% split(data[[split_variable]])
  
  split_plots <- split_data %>% 
    map2(.y = names(.),
         ~ggplot(data = .x, 
                 mapping = aes_string(x = x_axis, y = y_axis),
                 alpha = .85) + 
           geom_smooth(formula = y~x, method = 'lm') + 
           geom_point() + 
           theme_minimal() + 
           ggtitle(.y))
  
  if(!static){
    split_plots %<>% map(plotly::ggplotly)
  }

  return(split_plots)
}

split_plot(data = iris,
           split_variable = 'Species',
           x_axis = 'Sepal.Length',
           y_axis = 'Sepal.Width')

# Demo 2 ------------------------------------------------------------------

# plot the relationship of each other stat vs_hp ???

# plot the relationship of each other stat vs hp

stats <- c('attack', 'defense', 'sp_atk', 'sp_def') %>% 
  purrr::set_names(.)


map(.x = stats,
    .f = ~chronicle::make_scatterplot(dt = pkmn,
                                     x = .x,
                                     y = 'hp', 
                                     show_trend = TRUE, 
                                     trend_method = 'lm'))

hp_relationship <- map(.x = stats,
    .f = ~chronicle::make_scatterplot(dt = pkmn,
                                      x = .x,
                                      y = 'hp',
                                      groups = 'type_1', 
                                      faceted = TRUE,
                                      show_trend = TRUE, 
                                      trend_method = 'lm', 
                                      static = TRUE, 
                                      scales = 'free') + 
      ggtitle(.x)) %>%
  map(plotly::ggplotly)


hp_relationship$sp_atk

plot_all_vs_one <- function(data, variable, groups, static = TRUE){
  # identify all columns 
  cols <- colnames(data) %>% 
    purrr::set_names(.) %>% 
    setdiff(variable)
  
  var_vs_all <- map(.x = cols,
                         .f = ~chronicle::make_scatterplot(dt = data,
                                                           x = .x,
                                                           y = variable,
                                                           groups = groups, 
                                                           faceted = TRUE,
                                                           show_trend = is.numeric(data[[.x]]), 
                                                           trend_method = 'lm', 
                                                           static = TRUE, 
                                                           scales = 'free') + 
                           ggtitle(.x))
  
  if(!static){
    var_vs_all %<>% map(plotly::ggplotly)
  }
  return(var_vs_all)
}

plot_all_vs_one(data = iris, variable = 'Sepal.Width', groups = 'Species', static = TRUE)


colnames(palmerpenguins::penguins) %>% set_names()

# Demo 3 ------------------------------------------------------------------

#' Check if the given parameter is of a specific class
#'
#' @param param Object to be checked.
#' @param param_name Name of the parameter.
#' @param checking_function The function to evaluate. Must return a boolean value (eg is.character, is.finite, is.data.frame)
#' @param class_name Name of the class to place in the error message
#' @param allow_null Skip the error if param is NULL. Default is FALSE.
#'
#' @return Returns an error message if param is not a ", class_name, ".
#' @export
#'
#' @examples
check_class <- function(param,
                        param_name,
                        checking_function,
                        class_name,
                        allow_null = FALSE){
  if(!checking_function(param) | (allow_null & is.null(param))){
    stop("'", param_name, "' parameter must be a ",  class_name,
         ", but a ", paste(class(param), collapse = ' '), " was passed.")
  }
}


# make particular cases 

#' Check if the given parameter is a character vector
#'
#' @param param Object to be checked.
#' @param param_name Name of the parameter.
#' @param allow_null Skip the error if param is NULL. Default is FALSE.
#'
#' @return Returns an error message if param is not a character vector.
#' @export
check_char <- function(param, param_name, allow_null = FALSE){
  check_class(param = param,
              param_name = param_name,
              checking_function = is.character,
              class_name = 'character vector')
}

#' Check if the given parameter is a numeric vector
#'
#' @param param Object to be checked.
#' @param param_name Name of the parameter.
#' @param allow_null Skip the error if param is NULL. Default is FALSE.
#'
#' @return Returns an error message if param is not a numeric vector.
#' @export
check_num <- function(param, param_name, allow_null = FALSE){
  check_class(param = param,
              param_name = param_name,
              checking_function = is.numeric,
              class_name = 'numeric vector')
}



# make all of them in one call --------------------------------------------

make_check_function <- function(suffix, check_fun, class_name){
  check_this <- paste0("#' Check if the given parameter is a ", class_name, "
#'
#' @param param Object to be checked.
#' @param param_name Name of the parameter.
#' @param allow_null Skip the error if param is NULL. Default is FALSE.
#'
#' @return Returns an error message if param is not a ", class_name, ".
#' @export
check_", suffix, " <- function(param, param_name, allow_null = FALSE){
  check_class(param = param,
              param_name = param_name,
              checking_function = ", check_fun, ",
              class_name = '", class_name, "')
}\n\n")
  cat(check_this)
}

function_specs <- data.table(suffix = c('char', 'num', 'dt', 'df', 'logical'),
                            check_fun = c('is.character',
                                          'is.numeric',
                                          'data.table::is.data.table',
                                          'is.data.frame',
                                          'is.logical'),
                            class_name = c('character vector',
                                           'numeric vector',
                                           'data.table',
                                           'data.frame',
                                           'logical vector'))
purrr::pwalk(.l = function_specs,
             .f = make_check_function)


# check functions ---------------------------------------------------------


#' Check if the given parameter is a character vector
#'
#' @param param Object to be checked.
#' @param param_name Name of the parameter.
#' @param allow_null Skip the error if param is NULL. Default is FALSE.
#'
#' @return Returns an error message if param is not a character vector.
#' @export
check_char <- function(param, param_name, allow_null = FALSE){
  check_class(param = param,
              param_name = param_name,
              checking_function = is.character,
              class_name = 'character vector')
}

#' Check if the given parameter is a numeric vector
#'
#' @param param Object to be checked.
#' @param param_name Name of the parameter.
#' @param allow_null Skip the error if param is NULL. Default is FALSE.
#'
#' @return Returns an error message if param is not a numeric vector.
#' @export
check_num <- function(param, param_name, allow_null = FALSE){
  check_class(param = param,
              param_name = param_name,
              checking_function = is.numeric,
              class_name = 'numeric vector')
}

#' Check if the given parameter is a data.table
#'
#' @param param Object to be checked.
#' @param param_name Name of the parameter.
#' @param allow_null Skip the error if param is NULL. Default is FALSE.
#'
#' @return Returns an error message if param is not a data.table.
#' @export
check_dt <- function(param, param_name, allow_null = FALSE){
  check_class(param = param,
              param_name = param_name,
              checking_function = data.table::is.data.table,
              class_name = 'data.table')
}

#' Check if the given parameter is a data.frame
#'
#' @param param Object to be checked.
#' @param param_name Name of the parameter.
#' @param allow_null Skip the error if param is NULL. Default is FALSE.
#'
#' @return Returns an error message if param is not a data.frame.
#' @export
check_df <- function(param, param_name, allow_null = FALSE){
  check_class(param = param,
              param_name = param_name,
              checking_function = is.data.frame,
              class_name = 'data.frame')
}

#' Check if the given parameter is a logical vector
#'
#' @param param Object to be checked.
#' @param param_name Name of the parameter.
#' @param allow_null Skip the error if param is NULL. Default is FALSE.
#'
#' @return Returns an error message if param is not a logical vector.
#' @export
check_logical <- function(param, param_name, allow_null = FALSE){
  check_class(param = param,
              param_name = param_name,
              checking_function = is.logical,
              class_name = 'logical vector')
}



















# Bonus! purrr::reduce -----------------------------------------------------------

f(f(a,b), c)

# binary operations that are closed
purrr::reduce(type_tables, rbind)
purrr::reduce(type_tables, dplyr::left_join)


# Bonus 2! furrr: future + purrr -----------------------------------------------
library(furrr)
plan(multiprocess) # might take some time prepping

# https://github.com/DavisVaughan/furrr

library(tictoc)

tic('sequential')
map(c(2, 2, 2), ~Sys.sleep(.x))
toc()

tic('parallel')
future_map(c(2, 2, 2), ~Sys.sleep(.x))
toc()


# It's important to remember that data has to be passed back and forth between 
# the workers. This means that whatever performance gain you might have gotten 
# from your paralellization can be crushed by moving large amounts of data around. 

```


# Lecturas recomendadas

- La sección de [iteración](https://es.r4ds.hadley.nz/iteraci%C3%B3n.html) del libro R para ciencia de datos (traducción comunitaria del celebrado libro R for Data Science) R4DS)
- En realidad todo el libro de R para Ciencia de Datos
- 



# original: https://adv-r.hadley.nz/fp.html
# traducido: https://translate.google.com/translate?hl=&sl=en&tl=es&u=https%3A%2F%2Fadv-r.hadley.nz%2Ffunctionals.html

